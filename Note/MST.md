# ğŸ““ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (MST, Minimum Spanning Tree)
## Spanning Tree
ê·¸ë˜í”„ ë‚´ì˜ ëª¨ë“  ì •ì ì„ í¬í•¨í•˜ëŠ” íŠ¸ë¦¬

- ê·¸ë˜í”„ì˜ **ìµœì†Œ ì—°ê²° ë¶€ë¶„ ê·¸ë˜í”„**
- nê°œì˜ ì •ì ì„ ê°€ì§€ëŠ” ê·¸ë˜í”„ì˜ ìµœì†Œ ê°„ì„ ì˜ ìˆ˜ëŠ” (n-1)ê°œì´ê³ , (n-1)ê°œì˜ ê°„ì„ ìœ¼ë¡œ ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ í•„ì—°ì ìœ¼ë¡œ íŠ¸ë¦¬ í˜•íƒœê°€ ëœë‹¤
- ì¦‰, ê·¸ë˜í”„ì—ì„œ ì¼ë¶€ ê°„ì„ ì„ ì„ íƒí•´ì„œ ë§Œë“  íŠ¸ë¦¬

## MST
spanning tree ì¤‘ì—ì„œ **ì‚¬ìš©ëœ ê°„ì„ ë“¤ì˜ ê°€ì¤‘ì¹˜ í•©ì´ ìµœì†Œì¸ íŠ¸ë¦¬**

### íŠ¹ì§•
1. ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ í•©ì´ ìµœì†Œì—¬ì•¼ í•œë‹¤.
2. nê°œì˜ ì •ì ì„ ê°€ì§€ëŠ” ê·¸ë˜í”„ì— ëŒ€í•´ ë°˜ë“œì‹œ (n-1)ê°œì˜ ê°„ì„ ë§Œì„ ì‚¬ìš©í•´ì•¼ í•œë‹¤.
3. ì‚¬ì´í´ì´ í¬í•¨ë˜ì–´ì„œëŠ” ì•ˆëœë‹¤.

# MST êµ¬í˜„ ë°©ë²• ğŸ’¡
## 1. Kruskal MST ì•Œê³ ë¦¬ì¦˜
ë¹„ìš©ì— ë”°ë¼ ì •ë ¬ëœ ê°„ì„ ì„ í•˜ë‚˜ì”© ì„ íƒí•˜ë©° MSTë¥¼ ì°¾ëŠ” ë°©ë²•

### ë™ì‘ ì›ë¦¬
1. ì£¼ì–´ì§„ ëª¨ë“  ê°„ì„  ì •ë³´ì— ëŒ€í•´ ê°„ì„  ë¹„ìš©ì´ ë‚®ì€ ìˆœì„œë¡œ ì •ë ¬ì„ ìˆ˜í–‰
2. ì •ë ¬ëœ ê°„ì„  ì •ë³´ë¥¼ í•˜ë‚˜ì”© í™•ì¸í•˜ë©´ì„œ í˜„ì¬ì˜ ê°„ì„ ì´ ë…¸ë“œë“¤ ê°„ì˜ ì‚¬ì´í´ì„ ë°œìƒì‹œí‚¤ëŠ”ì§€ í™•ì¸
3. ë§Œì•½ ì‚¬ì´í´ì´ ë°œìƒí•˜ì§€ ì•Šì€ ê²½ìš°, ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— í¬í•¨ì‹œí‚¤ê³  ì‚¬ì´í´ì´ ë°œìƒí•œ ê²½ìš°, ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— í¬í•¨ì‹œí‚¤ì§€ ì•ŠìŒ
4. 1ë²ˆ~3ë²ˆì˜ ê³¼ì •ì„ ëª¨ë“  ê°„ì„  ì •ë³´ì— ëŒ€í•´ ë°˜ë³µ ìˆ˜í–‰

ë…¸ë“œë“¤ ê°„ì˜ ì‚¬ì´í´ì´ ë°œìƒí•˜ëŠ”ì§€ ì—¬ë¶€ëŠ” _ë…¸ë“œë“¤ì˜ ë¶€ëª¨ë…¸ë“œê°€ ê°™ë‹¤ë©´ ì‚¬ì´í´ì´ ë°œìƒ_, ê°™ì§€ ì•Šë‹¤ë©´ ì‚¬ì´í´ì´ ë°œìƒí•˜ì§€ ì•ŠìŒì„ ì˜ë¯¸í•œë‹¤.
<br>ì´ˆê¸°ë‹¨ê³„ - ê°„ì„ ì„ ì •ë ¬í•˜ê³ , ë¶€ëª¨ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ” í…Œì´ë¸”ì„ ìê¸° ìì‹ ì„ ë¶€ëª¨ë…¸ë“œë¡œ í•˜ë„ë¡ ê°’ì„ ì´ˆê¸°í™”
```python
v, e = map(int, input().split())

# ë¶€ëª¨ í…Œì´ë¸” ì´ˆê¸°í™”
parent = [0] * (v+1)
for i in range(1, v+1):
    parent[i] = i

# find ì—°ì‚°
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

# union ì—°ì‚°
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

# ê°„ì„  ì •ë³´ë¥¼ ë‹´ì„ ë¦¬ìŠ¤íŠ¸ì™€ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ê³„ì‚° ë³€ìˆ˜ ì •ì˜
edges= []
total_cost = 0

# ê°„ì„  ì •ë³´ë¥¼ ì…ë ¥ë°›ê³  ë¹„ìš©ì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
for _ in range(e):
    a, b, cost = map(int, input().split())
    edges.append((cost, a, b))

# ê°„ì„  ì •ë³´ë¥¼ ë¹„ìš© ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
edges.sort()

# ê°„ì„  ì •ë³´ë¥¼ í•˜ë‚˜ì”© í™•ì¸í•˜ë©´ì„œ í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ ìˆ˜í–‰
for i in range(e):
    cost, a, b = edges[i]
    # find ì—°ì‚° í›„, ë¶€ëª¨ë…¸ë“œê°€ ì„œë¡œ ë‹¤ë¥´ë©´ ì‚¬ì´í´ ë°œìƒí•˜ì§€ ì•Šìœ¼ë¯€ë¡œ union ì—°ì‚° ìˆ˜í–‰ -> ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— í¬í•¨
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent, a, b)
        total_cost += cost

print(total_cost)
```
## 2. Prim MST ì•Œê³ ë¦¬ì¦˜
ì‹œì‘ ì •ì ì—ì„œ ì¶œë°œí•˜ì—¬ ì •ì ì„ í•˜ë‚˜ì”© ì„ íƒí•˜ë©° ì‹ ì¥íŠ¸ë¦¬ ì§‘í•©ì„ í™•ì¥í•´ë‚˜ê°€ëŠ” ë°©ë²•

### ë™ì‘ ì›ë¦¬
1. ì‹œì‘ ë‹¨ê³„ì—ì„œëŠ” ì‹œì‘ ì •ì ë§Œì´ MST ì¡í•©ì— í¬í•¨ëœë‹¤.
2. ì• ë‹¨ê³„ì—ì„œ ë§Œë“¤ì–´ì§„ MST ì§‘í•©ì— ì¸ì ‘í•œ ì •ì ë“¤ ì¤‘ì—ì„œ **ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ì—°ê²°ëœ ì •ì ì„ ì„ íƒ**í•˜ì—¬ íŠ¸ë¦¬ë¥¼ í™•ì¥í•œë‹¤.
   - ì¦‰, ê°€ì¥ ë‚®ì€ ê°€ì¤‘ì¹˜ë¥¼ ë¨¼ì € ì„ íƒí•œë‹¤.
3. ìœ„ì˜ ê³¼ì •ì„ íŠ¸ë¦¬ê°€ (n-1)ê°œì˜ ê°„ì„ ì„ ê°€ì§ˆ ë•Œê¹Œì§€ ë°˜ë³µí•œë‹¤.

```python
import heapq
INF = int(1e9)

v, e = map(int, input().split())
graph = [[] for _ in range(v+1)]
visited = [0] * (v+1)

for i in range(e):
    u, v, weight = map(int, input().split())
    graph[u].append([weight, u, v])
    graph[v].append([weight, v, u])

# Prim ì•Œê³ ë¦¬ì¦˜
def prim(graph, start):
    q = []
    visited[start] = 1
    adj = graph[start]
    for i in adj:
        heapq.heappush(q, i)
    mst = []
    total_weight = 0
    while q:
        weight, u, v = heapq.heappop(q)
        if visited[v] == 0:
            visited[v] = 1
            mst.append((u, v))
            total_weight += weight
            
            for edge in graph[v]:
                if visited[edge[2]] == 0:
                    heapq.heappush(q, edge)
                    
    return total_weight

print(prim(graph, 1))
```


<br>[ì¶œì²˜] 
<br>https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html
<br>https://techblog-history-younghunjo1.tistory.com/262 
<br>https://deep-learning-study.tistory.com/595