# π““ Dijkstra - μµλ‹¨ κ²½λ΅ μ•κ³ λ¦¬μ¦

- **νΉμ •ν• λ…Έλ“**μ—μ„ μ¶λ°ν•μ—¬ **λ‹¤λ¥Έ λ¨λ“  λ…Έλ“**λ΅ κ°€λ” μµλ‹¨ κ²½λ΅λ¥Ό κ³„μ‚°
- λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦μ€ **μμ κ°„μ„ μ΄ μ—†μ„ λ•** μ •μƒμ μΌλ΅ λ™μ‘
- λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦μ€ κ·Έλ¦¬λ”” μ•κ³ λ¦¬μ¦μΌλ΅ λ¶„λ¥λ¨
  - λ§¤ μƒν™©μ—μ„ κ°€μ¥ λΉ„μ©μ΄ μ μ€ λ…Έλ“λ¥Ό μ„ νƒν•΄ μ„μμ κ³Όμ •μ„ λ°λ³µν•¨

### λ™μ‘ κ³Όμ •

1. μ¶λ° λ…Έλ“λ¥Ό μ„¤μ •ν•λ‹¤.
2. μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ„ μ΄κΈ°ν™”ν•λ‹¤. (λ¨λ“  λ…Έλ“λ¥Ό λ¬΄ν•μΌλ΅, μκΈ° μμ‹ μ€ 0μΌλ΅ μ„¤μ •)
3. λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“ μ¤‘μ—μ„ μµλ‹¨ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“λ¥Ό μ„ νƒν•λ‹¤.
4. ν•΄λ‹Ή λ…Έλ“λ¥Ό κ±°μ³ λ‹¤λ¥Έ λ…Έλ“λ΅ κ°€λ” λΉ„μ©μ„ κ³„μ‚°ν•μ—¬ μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ„ κ°±μ‹ ν•λ‹¤.
5. μ„ κ³Όμ •μ—μ„ 3, 4λ²μ„ λ°λ³µν•λ‹¤.

### λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦ νΉμ§•

- κ·Έλ¦¬λ”” μ•κ³ λ¦¬μ¦: λ§¤ μƒν™©μ—μ„ λ°©λ¬Έν•μ§€ μ•μ€ κ°€μ¥ λΉ„μ©μ΄ μ μ€ λ…Έλ“λ¥Ό μ„ νƒν•΄ μ„μμ κ³Όμ •μ„ λ°λ³µ
- λ‹¨κ³„λ¥Ό κ±°μΉλ©° ν• λ² μ²λ¦¬λ λ…Έλ“μ μµλ‹¨ κ±°λ¦¬λ” κ³ μ •λμ–΄ λ” μ΄μƒ λ°”λ€μ§€ μ•λ”λ‹¤.
- μ•κ³ λ¦¬μ¦μ„ μν–‰ν• λ’¤μ— ν…μ΄λΈ”μ— κ° λ…Έλ“κΉμ§€μ μµλ‹¨ κ±°λ¦¬ μ •λ³΄κ°€ μ €μ¥λλ‹¤.

### μ°μ„ μμ„ ν 'ν™' μ‚¬μ©

- μ‹κ°„λ³µμ΅λ„ O(ElogV)
- λ…Έλ“λ¥Ό ν•λ‚μ”© κΊΌλ‚΄ κ²€μ‚¬ν•λ” λ°λ³µλ¬Έμ€ λ…Έλ“μ κ°μ V μ΄μƒ νμλ΅λ” μ²λ¦¬λμ§€ μ•λ”λ‹¤.
  - κ²°κ³Όμ μΌλ΅ ν„μ¬ μ°μ„ μμ„ νμ—μ„ κΊΌλ‚Έ λ…Έλ“μ™€ μ—°κ²°λ λ‹¤λ¥Έ λ…Έλ“λ“¤μ„ ν™•μΈν•λ” μ΄ νμλ” μµλ€ κ°„μ„ μ κ°μ(E)λ§νΌ μ—°μ‚°μ΄ μν–‰λ  μ μλ‹¤.
- μ½”λ“ μμ‹

```python
# μ°μ„ μμ„ ν ν™μ„ μ‚¬μ©ν•μ—¬ κµ¬ν„
import heapq
import sys
input = sys.stdin.readline

# λ¬΄ν•μ„ μλ―Έν•λ” 10μ–µμ„ μ„¤μ •
INF = int(1e9)

# λ…Έλ“μ κ°μ, κ°„μ„ μ κ°μ μ…λ ¥λ°›κΈ°
n, m = map(int, input().split())
# μ‹μ‘ λ…Έλ“ λ²νΈ μ…λ ¥λ°›κΈ°
start = int(input())
# κ° λ…Έλ“μ— μ—°κ²°λμ–΄ μλ” λ…Έλ“μ— λ€ν• μ •λ³΄λ¥Ό λ‹΄λ” λ¦¬μ¤νΈ λ§λ“¤κΈ°
graph = [[] for _ in range(n+1)]
# μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ„ λ¨λ‘ λ¬΄ν•μΌλ΅ μ΄κΈ°ν™”
distance = INF * (n+1)

# λ¨λ“  κ°„μ„  μ •λ³΄λ¥Ό μ…λ ¥λ°›κΈ°
for _ in range(m):
    a, b, c = map(int, input().split())
    # aλ² λ…Έλ“μ—μ„ bλ² λ…Έλ“λ΅ κ°€λ” λΉ„μ©μ΄ cλΌλ” μλ―Έ
    graph[a].append((b, c))

def dijkstra(start):
    q = []
    # μ‹μ‘ λ…Έλ“λ΅ κ°€κΈ° μ„ν• μµλ‹¨ κ±°λ¦¬λ” 0μΌλ΅ μ„¤μ •ν•μ—¬, νμ— μ‚½μ…
    heapq.heappush(q, (0, start))
    distance[start] = 0
    while q: # νκ°€ λΉ„μ–΄μμ§€ μ•λ‹¤λ©΄
        # κ°€μ¥ μµλ‹¨ κ±°λ¦¬κ°€ μ§§μ€ λ…Έλ“μ— λ€ν• μ •λ³΄λ¥Ό κΊΌλ‚΄κΈ°
        dist, now = heapq.heappop(q)
        # ν„μ¬ κΊΌλ‚Έ λ…Έλ“μ μ΄λ―Έ μ €μ¥λ μµλ‹¨ κ±°λ¦¬κ°€ μ΄ν›„μ— κ³„μ‚°λ κ±°λ¦¬λ³΄λ‹¤ μ‘μΌλ©΄ κ±΄λ„λ›°κΈ°
        if distance[now] < dist:
            continue
        # ν„μ¬ λ…Έλ“μ™€ μ—°κ²°λ λ‹¤λ¥Έ μΈμ ‘ν• λ…Έλ“λ“¤μ„ ν™•μΈ
        for i in graph[now]:
            cost = dist + i[1]
            # ν„μ¬ λ…Έλ“λ¥Ό κ±°μ³μ„ λ‹¤λ¥Έ λ…Έλ“λ΅ μ΄λ™ν•λ” κ±°λ¦¬κ°€ λ” μ§§μ€ κ²½μ°
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))

# λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦ μν–‰
dijkstra(start)

# λ¨λ“  λ…Έλ“λ΅ κ°€κΈ° μ„ν• μµλ‹¨ κ±°λ¦¬λ¥Ό μ¶λ ¥
for i in range(1, n+1):
    # λ„λ‹¬ν•  μ μ—†λ” κ²½μ°, λ¬΄ν•(INFINITY)μ΄λΌκ³  μ¶λ ¥
    if distance[i] == INF:
        print("INFINITY")
    # λ„λ‹¬ν•  μ μλ” κ²½μ° κ±°λ¦¬λ¥Ό μ¶λ ¥
    else:
        print(distance[i])
```

[μ¶μ²] - μ΄κ²ƒμ΄ μ½”λ”© ν…μ¤νΈλ‹¤ with Python
